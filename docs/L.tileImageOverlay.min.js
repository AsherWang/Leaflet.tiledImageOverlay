!function(t,i){"function"==typeof define&&define.amd?define(["leaflet"],t):"object"==typeof exports&&(module.exports=t(require("leaflet"))),void 0!==i&&i.L&&(i.L.tileImageOverlay=t(L))}(t=>{const{Util:i}=t,o=t.LayerGroup.extend({options:{leftTop:[0,0],rightBottom:void 0,z:"",autoFit:!1,onAutoFit:void 0,tileUrl:"",subdomains:"abc",startX:0,startY:0,col:1,row:1,blockSize:128,width:void 0,height:void 0},initialize(o){i.setOptions(this,o);const{blockSize:s}=this.options;this.options.images||this.options.tileUrl?(this.options.width=this.options.width||s*this.options.col,this.options.height=this.options.height||s*this.options.row,this._addImages(!1)):t.canvasOverlay?(this.options.width=this.options.width||this.options.image.width,this.options.height=this.options.height||this.options.image.height,this.options.col=Math.ceil(this.options.image.width/s),this.options.row=Math.ceil(this.options.image.height/s),this._addImages(!0)):console.warn("do you forget to add script L.canvasOverlay?")},_addImages(i){const o=this.options,s=[];this._images=[];const{subdomains:e,blockSize:h}=o,[n,a]=this.options.leftTop;if(this.options.rightBottom){const[t,i]=this.options.rightBottom;this._pxLatRate=Math.abs(n-t)/this.options.height,this._pxLngRate=Math.abs(a-i)/this.options.width,this._bounds=[[n,a],[t,i]],this._center=[(n+t)/2,(a+i)/2]}else this._pxLatRate=1,this._pxLngRate=1,this._bounds=[[n,a],[n-this.options.height,a+this.options.width]],this._center=[n-this.options.height/2,a+this.options.width/2];const d=h*this._pxLngRate,p=h*this._pxLatRate;for(let l=0;l<o.row;l+=1)for(let r=0;r<o.col;r+=1){const c=[[n-p*l,a+d*r],[n-p*(l+1),a+d*(r+1)]];if(i){const i=h*r,e=h*l;s.push(t.canvasOverlay(c,{drawFn(t,s){s.width=1.2*h,s.height=1.2*h,t.drawImage(o.image,i,e,h,h,0,0,s.width,s.height)}}))}else{const i=o.startX+r,h=o.startY+l,n=o.images?o.images[l*o.col+r]:o.tileUrl.replace("{x}",i).replace("{y}",h).replace("{z}",o.z).replace("{s}",e[(i+h)%e.length]);this._images.push(n),s.push(t.imageOverlay(n,c))}}t.LayerGroup.prototype.initialize.call(this,s),this.setZIndex(0),this.on("add",function(){o.autoFit&&this._autoFit()})},_autoFit(){const i=this._map,o=i.getSize(),s=o.x/o.y,e=Math.abs(this._bounds[0][0]-this._bounds[1][0]),h=Math.abs(this._bounds[0][1]-this._bounds[1][1]),n=h/e,a=this._center;Math.min(Math.abs(this._bounds[0][0]-this._bounds[1][0]),Math.abs(this._bounds[0][1]-this._bounds[1][1]));let d;const p=n<s;if(p){const t=h/s;d=[[a[0]+t/2,a[1]-h/2],[a[0]-t/2,a[1]+h/2]]}else{const t=e*s;d=[[a[0]+e/2,a[1]-t/2],[a[0]-e/2,a[1]+t/2]]}const l=i.getBoundsZoom(d,p),r=l,c=Math.max(l,r+3);if(this.options.onAutoFit){const t={minZoom:r,z:l,maxZoom:c,center:a,maxBounds:this._bounds};this.options.onAutoFit(t)}else i.setView(a,l).setMaxBounds(this._bounds).setMinZoom(r).setMaxZoom(c);this.options.debug&&(t.marker(a).addTo(i),this._addPolygon(this._bounds),this._addPolygon(d,"blue"))},_addPolygon(i,o="red"){const s=i[0],e=i[1],h=[s,[s[0],e[1]],e,[e[0],s[1]]];t.polygon(h,{color:o}).addTo(this._map)}});return function(t){return new o(t)}},window);